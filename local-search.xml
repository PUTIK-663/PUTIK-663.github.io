<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>006_C语言中scanf与分隔符(空格、回车、tab)</title>
    <link href="/2022/03/31/006_C%E8%AF%AD%E8%A8%80%E4%B8%ADscanf%E4%B8%8E%E5%88%86%E9%9A%94%E7%AC%A6-%E7%A9%BA%E6%A0%BC%E3%80%81%E5%9B%9E%E8%BD%A6%E3%80%81tab/"/>
    <url>/2022/03/31/006_C%E8%AF%AD%E8%A8%80%E4%B8%ADscanf%E4%B8%8E%E5%88%86%E9%9A%94%E7%AC%A6-%E7%A9%BA%E6%A0%BC%E3%80%81%E5%9B%9E%E8%BD%A6%E3%80%81tab/</url>
    
    <content type="html"><![CDATA[<p>众所周知，C语言中的scanf函数的作用是从标准输入设备(通常是键盘)读取输入值，并存储到参数列表中指针所指向的内存单元。下面从几个方面说一下一些稍微细节的东西。下面的实验都在vc6.0中通过。</p><h3 id="一、scanf的返回值"><a href="#一、scanf的返回值" class="headerlink" title="一、scanf的返回值"></a>一、scanf的返回值</h3><p>scanf通常返回的是成功赋值(从标准输入设备赋值到参数列表所指定的内存区域)的数据项数，如果出错或是遇到“end of file”（注意，如果想从键盘输入EOF，在windows的DOS窗口用Ctrl+Z 或F6；在UNIX系统上，用CTRL+D），则返回EOF，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br></code></pre></td></tr></table></figure><p>如果x和y都被成功读入，那么scanf的返回值就是2;<br>如果只有x被成功读入，返回值为1;<br>如果x和y都未被成功读入，返回值为0;<br>如果遇到错误或遇到end of file，返回值为EOF。</p><h3 id="二、scanf的处理机制"><a href="#二、scanf的处理机制" class="headerlink" title="二、scanf的处理机制"></a>二、scanf的处理机制</h3><p>scanf以删除的方式从缓冲区读入数据(来自标准输入设备的数据存储在缓冲区)，也就是说，scanf从缓冲区读入一个数据项，该数据项在缓冲区中就被清除掉了。而如果scanf需要读取一个数据项，返现缓冲区当前是空的，那么程序就会在scanf代码处阻塞，等待用户输入，scanf函数接收到相应的数据项之后，在缓冲区中将这一数据项清除，scanf函数返回，程序继续执行。</p><h3 id="三、scanf对不同类型输入的处理方式"><a href="#三、scanf对不同类型输入的处理方式" class="headerlink" title="三、scanf对不同类型输入的处理方式"></a>三、scanf对不同类型输入的处理方式</h3><p>首先，要清楚一个概念：空白字符(white space)。一般，程序中所指的空白字符是指空格(space)，回车(enter)和指标符(table)。</p><h4 id="1、整数-d"><a href="#1、整数-d" class="headerlink" title="1、整数 %d"></a>1、整数 %d</h4><p>对于整型数据的输入，也就是说”%d”类型的输入，scanf默认的分割符是所有的空白字符(空格，回车和指标符都行)。也就是说如果一个scanf函数中出现scanf(“%d%d”,&amp;a,&amp;b)，那么用任何一个空白字符来分隔两个整数a,b的值，变量a,b都可以接收到正确的输入。另外，要注意的是，scanf对于数字输入，会忽略输入数据项前面的空白字符。下面是例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>    <span class="hljs-type">int</span> a,b; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)!=EOF) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d\n&quot;</span>,a,b); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C">Output: <br>Input the value of a and b:<span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b:<span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b:<span class="hljs-number">123</span> <br><span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b: <br><span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b:   <span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b: <span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b:^Z <br>Press any key to <span class="hljs-keyword">continue</span>...<br></code></pre></td></tr></table></figure><h4 id="2、字符串-s"><a href="#2、字符串-s" class="headerlink" title="2、字符串 %s"></a>2、字符串 %s</h4><p>scanf对于字符串输入的处理和对整数类似，会忽略前导的空白字符，而且默认的分隔符是所有的空白字符。但是，要注意的是，由于C语言中，没有string类型，都是用char型数组来表示。因此，scanf会为每一个输入的字符串最后加一个‘\0’。下面是一个例子，可以看出scanf这货的边界控制还是要小心。如下例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>    <span class="hljs-type">char</span> a[<span class="hljs-number">5</span>],b[<span class="hljs-number">5</span>]; <br>    <span class="hljs-type">int</span> i; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,a,b)!=EOF) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%s,b=%s\n&quot;</span>,a,b); <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:(%c) &quot;</span>,a[i],a[i]); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:(%c) &quot;</span>,b[i],b[i]); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2022/03/31/006_C%E8%AF%AD%E8%A8%80%E4%B8%ADscanf%E4%B8%8E%E5%88%86%E9%9A%94%E7%AC%A6-%E7%A9%BA%E6%A0%BC%E3%80%81%E5%9B%9E%E8%BD%A6%E3%80%81tab/clip_image001.png"> </p><h4 id="3、字符-c"><a href="#3、字符-c" class="headerlink" title="3、字符 %c"></a>3、字符 %c</h4><p>scanf在处理对字符数据的输入时，既不会忽略前导空白字符，默认也没有任何分隔字符。所有的字符，包括空白字符都会被当成输入字符。下面是例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>    <span class="hljs-type">char</span> a ,b ; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%c&quot;</span>,&amp;a,&amp;b)!=EOF) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%c,b=%c\n&quot;</span>,a,b); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2022/03/31/006_C%E8%AF%AD%E8%A8%80%E4%B8%ADscanf%E4%B8%8E%E5%88%86%E9%9A%94%E7%AC%A6-%E7%A9%BA%E6%A0%BC%E3%80%81%E5%9B%9E%E8%BD%A6%E3%80%81tab/clip_image002.png"><br> 可以看出，在对字符数据输入的时候，由于缓冲区中有回车空格等数据，会导致输入数据比较诡异，为了解决这个问题，有以下方法：</p><p><strong>(1) 清空缓冲区</strong></p><p>在微软系统中，有一个名为fflush(stdin)的函数，可以用来清空缓冲区，如下例4：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>    <span class="hljs-type">char</span> a ,b ; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%c&quot;</span>,&amp;a,&amp;b)!=EOF) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%c,b=%c\n&quot;</span>,a,b); <br>        fflush(<span class="hljs-built_in">stdin</span>); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2022/03/31/006_C%E8%AF%AD%E8%A8%80%E4%B8%ADscanf%E4%B8%8E%E5%88%86%E9%9A%94%E7%AC%A6-%E7%A9%BA%E6%A0%BC%E3%80%81%E5%9B%9E%E8%BD%A6%E3%80%81tab/clip_image003.png"> </p><p> <strong>(2)将缓冲区的数据读出来</strong></p><p>有的编译系统并没有定义stdin的fflush操作，这个时候，可以把缓冲区中的数据读出来，有如下几种可行的方法：</p><p>①getchar()</p><p>将例4中的 fflush(stdin); 语句换成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span>((c=getchar())!=<span class="hljs-string">&#x27;\n&#x27;</span>&amp;&amp;c!=EOF);<br></code></pre></td></tr></table></figure><p>运行效果和上面的相同。</p><p>②gets()</p><p>char* gets(char* buffer)从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer指针所指向的字符数组中。换行符不作为读取串的内容，读取的换行符被转换为null值，并由此来结束字符串。读入成功，返回与参数buffer相同的指针；读入过程中遇到EOF(End-of-File)或发生错误，返回NULL指针。所以在遇到返回值为NULL的情况，要用ferror或feof函数检查是发生错误还是遇到EOF。<br>要注意的是gets函数可以无限读取，不会判断上限，所以应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。如果溢出，多出来的字符将被写入到堆栈中，这就覆盖了堆栈原先的内容，破坏一个或多个不相关变量的值。</p><p>将例4中的 fflush(stdin); 语句换成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> c[<span class="hljs-number">10</span>];<br>gets(c);<br></code></pre></td></tr></table></figure><p>运行效果也和上面的相同。</p><h4 id="4、在stackoverflow上看到的一个问题"><a href="#4、在stackoverflow上看到的一个问题" class="headerlink" title="4、在stackoverflow上看到的一个问题"></a>4、在stackoverflow上看到的一个问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span> </span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> a[<span class="hljs-number">4</span>]; <br>    <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%s\n&quot;</span>, a); <br>    <span class="hljs-keyword">return</span> a; <br>&#125; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    <span class="hljs-type">char</span> *h = method1(); <br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;%s\n&quot;</span>, h); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">ab <br>cd <br>ab <br>Press any key to <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>可以发现，输如两次之后才会输出。这个现象比较诡异，原因如下：</p><p>White space (such as blanks, tabs, or newlines) in the format string match any amount of white space, including none, in the input. Everything else matches only itself.<br>Thus with scanf (“%s\n”, a) it will scan for a string followed by optional white space. Since after the first newline more whitespace may follow, scanf is not done after the first newline and looks what’s next. You will notice that you can enter any number of newlines (or tabs or spaces) and scanf will still wait for more.<br>However, when you enter the second string, the sequence of whitespace is delimited and scanning stops.</p><h6 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.csdndoc.com/article/4341194">https://www.csdndoc.com/article/4341194</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>-C语言</tag>
      
      <tag>-转载</tag>
      
      <tag>-编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>005_不理解缓冲区导致数据输出异常</title>
    <link href="/2022/03/30/005-%E4%B8%8D%E7%90%86%E8%A7%A3%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/03/30/005-%E4%B8%8D%E7%90%86%E8%A7%A3%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>作为一个以C语言作为编程启蒙的初学者，在学习C语言时也是遇到了许多问题，例如接下来要说到的”<strong>缓冲区理解问题</strong>“，有的时候如果<strong>把gets函数和scanf函数连用</strong>总会发生奇葩的错误，而如果不理解缓冲区这个概念的话，是很难明白为什么会发生这样或那样的错误的。在解决问题的过程中，搜索到了一篇写得很好的文章，在这里记录一下。</p><h2 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h2><h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h3><p>从一个简单的例子开始：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">20</span>] ;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>] ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入文件名:&quot;</span>) ;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span> , a ) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入关键字:&quot;</span>) ;<br>    <span class="hljs-comment">//getchar() ;//fflush(stdin);</span><br>    gets(str) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span> , str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/03/30/005-%E4%B8%8D%E7%90%86%E8%A7%A3%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E5%BC%82%E5%B8%B8/clip_image001.jpg" alt="输入jj后回车程序就结束了">  </p><p>可以看到没等第二次的关键字的输入程序就运行结束了，这是为什么呢？要充分理解这个问题我们需要理解C语言中对缓冲区的概念。</p><p>在这之前我们初步分析一下，scanf函数输入字符串的的情况下空白字符（空格，回车，Tab）都只是被视为分隔符，关于这一点可以参考 <a href="./2022/03/31/006_C%E8%AF%AD%E8%A8%80%E4%B8%ADscanf%E4%B8%8E%E5%88%86%E9%9A%94%E7%AC%A6-%E7%A9%BA%E6%A0%BC%E3%80%81%E5%9B%9E%E8%BD%A6%E3%80%81tab/">C语言中scanf与分隔符（空格回车Tab)</a> 这篇博文，当我们输入字符串jj后按回车的时候就会把jj连同换行符送入缓冲区，然而scanf只会接收字符串jj，并把这个字符串送入到以a为首地址的地址空间中，同时在字符串后面自动加上一个 \0 ，那么如今缓冲区内就只有一个换行符了。当执行到gets()函数的时候，因为缓冲区内非空，那么gets直接会读取缓冲区中的换行符复制到str为首地址的内存空间，同时在字符串后面自动加上一个 \0，所以输出的str的结果就是一个换行罢了。</p><p>当我们取消程序中注释语句getchar()的时候，getchar()会接收缓冲区中的而第一个字符，那么缓冲区便空了。当执行到gets()的时候，由于缓冲区为空，那么程序便会停在gets()位置处的等待输入。然后我们输入字符串并且按回车将字符串送入缓冲区后，因为gets()的功能是获取缓冲区中的字符串，遇到换行符或者EOF后停止，所以gets()取出缓冲区内所有的字符串以及换行符，所以输出的结果如下图示：</p><p><img src="/2022/03/30/005-%E4%B8%8D%E7%90%86%E8%A7%A3%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E5%BC%82%E5%B8%B8/clip_image002.jpg" alt="使用getchar()读取缓冲区剩余内容"><br> 可以看到连同换行符也一起输出来了。</p><p>当然除了使用getchar()来消除换行符的影响，也可以使用fflush(stdin)来刷新缓冲区，同样可以起到消除换行符的效果。因为fflush(stdin)的作用是清除标准输入缓冲区中的内容。</p><h3 id="2-缓冲区介绍"><a href="#2-缓冲区介绍" class="headerlink" title="2.缓冲区介绍"></a>2.缓冲区介绍</h3><p>有了一些感性的认识，我们来看看缓冲区的概念和它的机制。</p><h4 id="（1）什么是缓冲区"><a href="#（1）什么是缓冲区" class="headerlink" title="（1）什么是缓冲区"></a>（1）什么是缓冲区</h4><p>缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。</p><p>缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。</p><h4 id="（2）为什么要引入缓冲区"><a href="#（2）为什么要引入缓冲区" class="headerlink" title="（2）为什么要引入缓冲区"></a>（2）为什么要引入缓冲区</h4><p>我们为什么要引入缓冲区呢？</p><p>比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。</p><p>又比如，我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。</p><p>现在您基本明白了吧，缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。</p><h4 id="（3）缓冲区的类型"><a href="#（3）缓冲区的类型" class="headerlink" title="（3）缓冲区的类型"></a>（3）缓冲区的类型</h4><p>缓冲区 分为三种类型：全缓冲、行缓冲和不带缓冲。</p><p><strong>①全缓冲：</strong>在这种情况下，当填满标准I&#x2F;O缓存后才进行实际I&#x2F;O操作。全缓冲的典型代表是对磁盘文件的读写。</p><p><strong>②行缓冲：</strong>在这种情况下，当在输入和输出中遇到换行符时，执行真正的I&#x2F;O操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I&#x2F;O操作。典型代表是键盘输入数据。</p><p><strong>③不带缓冲：</strong>也就是不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来。</p><h4 id="（4）缓冲区的刷新"><a href="#（4）缓冲区的刷新" class="headerlink" title="（4）缓冲区的刷新"></a>（4）缓冲区的刷新</h4><p>下列情况会引发缓冲区的刷新:</p><ul><li>缓冲区满时;</li><li>执行flush语句;</li><li>执行endl语句;</li><li>关闭文件。</li></ul><p>可见，缓冲区满或关闭文件时都会刷新缓冲区，进行真正的I&#x2F;O操作。另外，在C++中，我们可以使用flush函数来刷新缓冲区(执行I&#x2F;O操作并清空缓冲区)键盘操作演示行缓冲。</p><p>先介绍getchar()函数：</p><p>函数原型：int getchar(void);</p><p>说明：当程序调用getchar()函数时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止(回车字符也放在缓冲区中)。当用户键入回车之后，getchar()函数才开始从键盘缓冲区中每次读入一个字符。也就是说，后续的getchar()函数调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才重新等待用户按键。</p><p>不知道您明白了没有，再通俗一点讲，当程序调用getchar()函数时，程序就等着用户按键，并等用户按下回车键返回。期间按下的字符存放在缓冲区，第一个字符作为函数返回值。继续调用getchar()函数，将不再等用户按键，而是返回您刚才输入的第2个字符;继续调用，返回第3个字符，直到缓冲区中的字符读完后，才等待用户按键。</p><p>getchar()函数的执行就是采用了行缓冲。第一次调用getchar()函数，会让程序使用者(用户)输入一行字符并直至按下回车键 函数才返回。此时用户输入的字符和回车符都存放在行缓冲区。再次调用getchar()函数，会逐步输出行缓冲区的内容。</p><p>运行一段代码体会一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> c ;<br>    c = getchar() ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %c\n&quot;</span> , c ) ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p> 运行结果：</p><p><img src="/2022/03/30/005-%E4%B8%8D%E7%90%86%E8%A7%A3%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E5%BC%82%E5%B8%B8/clip_image004.jpg" alt="s后面的输入由于缓冲区已满而被无视"> </p><p>不断输入数据，当不能再输入数据的时候说明缓冲区已满，输入的字符的数目为4096，即4k。那么就可以知道缓冲区的大小为4k。</p><h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.csdndoc.com/article/4341477">https://www.csdndoc.com/article/4341477</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>-C语言</tag>
      
      <tag>-转载</tag>
      
      <tag>-编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>004_vc6.0出现_oax1错误</title>
    <link href="/2022/03/30/004_vc6.0%E5%87%BA%E7%8E%B0_oax1%E9%94%99%E8%AF%AF/"/>
    <url>/2022/03/30/004_vc6.0%E5%87%BA%E7%8E%B0_oax1%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>一般情况下是代码中夹杂了中文字符。</p>]]></content>
    
    
    
    <tags>
      
      <tag>-原创</tag>
      
      <tag>-C语言</tag>
      
      <tag>-编译报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>003_vc6.0添加插件时error解决方案</title>
    <link href="/2022/03/29/003_vc6.0%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6%E6%97%B6error%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2022/03/29/003_vc6.0%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6%E6%97%B6error%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="Unable-to-register-this-add-in-because-its-DllRegisterServer-returns-an-error-解决方案"><a href="#Unable-to-register-this-add-in-because-its-DllRegisterServer-returns-an-error-解决方案" class="headerlink" title="Unable to register this add-in because its DllRegisterServer returns an error 解决方案"></a>Unable to register this add-in because its DllRegisterServer returns an error 解决方案</h3><p>详细步骤：</p><p><strong>1、</strong>以管理员身份重新启动VC6.0</p><p><strong>2、</strong>windows下使用administrator(管理员)身份登录，在”开始”菜单的搜索框中输入cmd回车，就可以看到该控制台程序了，然后右键单击，选择”以管理员身份运行”，此时就获得了管理员权限。或者进C:\Windows\System32 找到 cmd.exe 右键–管理员身份运行</p><p><strong>3、</strong>在弹出的命令窗口中使用注册命令</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs C">regsvr32.exe <span class="hljs-string">&quot;add-in.dll&quot;</span><br></code></pre></td></tr></table></figure><p>例如：如果安装目录在c盘，只输入引号内的命令，进入c盘目录下然后输入命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">c:\&gt;regsvr32.exe <span class="hljs-string">&quot;c:\VC6CN\COMMON\MSDEV98\ADDINS\FileTool.dll&quot;</span><br></code></pre></td></tr></table></figure><p>成功后，此时VC界面中会出现一个上面只有两个图标的工具栏，可以将其拖放到自己认为合适的位置，然后关闭VC6.0并重新启动程序</p><h6 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://www.docin.com/">www.docin.com</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>注：由于该笔记历史久远，是当时学习C语言时使用VC6.0遇到的问题，由于没把笔记写好，我自己也看不懂了，故本经验参考性不大<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>-原创 -VC6.0 -IDE环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>002_void及void指针含义的深刻解析</title>
    <link href="/2022/03/29/002_void%E5%8F%8Avoid%E6%8C%87%E9%92%88%E5%90%AB%E4%B9%89%E7%9A%84%E6%B7%B1%E5%88%BB%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/03/29/002_void%E5%8F%8Avoid%E6%8C%87%E9%92%88%E5%90%AB%E4%B9%89%E7%9A%84%E6%B7%B1%E5%88%BB%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="简化版概述"><a href="#简化版概述" class="headerlink" title="简化版概述"></a>简化版概述</h2><h3 id="一、void-的含义"><a href="#一、void-的含义" class="headerlink" title="一、void 的含义"></a>一、void 的含义</h3><p>  void 即“无类型”，void *则为“无类型指针”，可以指向任何数据类型。 </p><h3 id="二、void-指针使用规范"><a href="#二、void-指针使用规范" class="headerlink" title="二、void 指针使用规范"></a>二、void 指针使用规范</h3><p><strong>①void 指针可以指向任意类型的数据，亦即可用任意数据类型的指针对 void 指针赋值。</strong></p><p>例如： </p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *pint;<br><span class="hljs-type">void</span> *pvoid; <br>pvoid = pint;  <span class="hljs-comment">//不过不能 pint = pvoid;</span><br></code></pre></td></tr></table></figure><p> 如果要将 pvoid 赋给其他类型指针，则需要强制类型转换如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">pint = (<span class="hljs-type">int</span> *)pvoid;<br></code></pre></td></tr></table></figure><p>**②在 ANSI C 标准中，不允许对 void 指针进行算术运算如 pvoid++或 pvoid+&#x3D;1 等，而在 GNU 中则允许，因为在缺省情况下，GNU 认为 void *与 char <em>一样。 sizeof( <em>pvoid )&#x3D;&#x3D; sizeof( char )。</em></em></p><h3 id="三、void-的作用"><a href="#三、void-的作用" class="headerlink" title="三、void 的作用"></a>三、void 的作用</h3><p><strong>①对函数返回的限定。</strong></p><p><strong>②对函数参数的限定。</strong> </p><p>当函数不需要返回值时，必须使用 void 限定。例如： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br></code></pre></td></tr></table></figure><p>当函数不允许接受参数时，必须使用 void 限定。例如： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>由于 void 指针可以指向任意类型的数据，亦即可用任意数据类型的指针对 void 指针赋值，因此还可以用 void 指针来作为函数形参，这样函数就可以接受任意数据类型的指针作为参数。例如： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> * <span class="hljs-title function_">memcpy</span><span class="hljs-params">( <span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len )</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">memset</span><span class="hljs-params">( <span class="hljs-type">void</span> * buffer, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> num )</span>;<br></code></pre></td></tr></table></figure><h2 id="详细版说明"><a href="#详细版说明" class="headerlink" title="详细版说明"></a>详细版说明</h2><p>许多初学者对 C&#x2F;C++语言中的 void 及 void 指针类型不甚理解，因此在使用上出现了一些错误。本文将对 void 关键字的深刻含义进行解说，并详述 void 及 void 指针类型的使用方法与技巧。 </p><h3 id="一、void-的含义-1"><a href="#一、void-的含义-1" class="headerlink" title="一、void 的含义"></a>一、void 的含义</h3><p>void 的字面意思是“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据。void 几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个 void 变量，让我们试着来定义：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">void a<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这行语句编译时会出错，提示“illegal use of type ’void’”。不过，即使 void a 的编译不会出错，它也没有任何实际意义。 void 真正发挥的作用在于：</p><p>（1）对函数返回的限定； </p><p>（2） 对函数参数的限定。 </p><p>众所周知，如果指针 p1 和 p2 的类型相同，那么我们可以直接在 p1 和 p2 间互相赋值；如果 p1 和 p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。 例如： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> *p1; <br><span class="hljs-type">int</span> *p2;<br>p1 = p2;<br></code></pre></td></tr></table></figure><p>其中 p1 &#x3D; p2 语句会编译出错，提示 “ ’&#x3D;’ : cannot convert from ’int *’ to ’ float *’ ”，必须改为： p1 &#x3D; (float *)p2; </p><p>而 void *则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> *p1; <br><span class="hljs-type">int</span> *p2;<br>p1 = p2; <br></code></pre></td></tr></table></figure><p>但这并不意味着，void *也可以无需强制类型转换地赋给其它类型的指针。因为 “无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”。道理很简单，我们可以说“男人和女人都是人”，但不能说“人是男人”或者“人是女人”。</p><p>下面的语句编译出错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> *p1; <br><span class="hljs-type">int</span> *p2;<br>p2 = p1; <br></code></pre></td></tr></table></figure><p>提示 “ ’&#x3D;’ : cannot convert from ’void *’ to ’int *’ ”。 </p><h3 id="二、void-的使用"><a href="#二、void-的使用" class="headerlink" title="二、void 的使用"></a>二、void 的使用</h3><p>下面给出 void 关键字的使用规则： </p><h5 id="规则一-：如果函数没有返回值，那么应声明为-void-类型。"><a href="#规则一-：如果函数没有返回值，那么应声明为-void-类型。" class="headerlink" title="规则一 ：如果函数没有返回值，那么应声明为 void 类型。"></a>规则一 ：如果函数没有返回值，那么应声明为 void 类型。</h5><p>在 C 语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是许多程序员却误以为其为 void 类型。例如： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">add ( <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b ) <br>&#123;<br>    <span class="hljs-keyword">return</span> a + b; <br>&#125; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> <br>&#123; <br>    <span class="hljs-built_in">printf</span> ( \<span class="hljs-string">&quot;2 + 3 = %d\&quot;, add ( 2, 3) ); </span><br><span class="hljs-string">&#125; </span><br></code></pre></td></tr></table></figure><p>程序运行的结果为输出： </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>+ <span class="hljs-number">3</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>这说明不加返回值说明的函数的确为 int 函数。 </p><p>林锐博士《高质量 C&#x2F;C++编程》中提到：“C++语言有很严格的类型安全检查，不允许上述情况（指函数不加类型声明）发生”。可是编译器并不一定这么认定，譬如在 Visual C++6.0 中上述 add 函数的编译无错也无警告且运行正确，所以不能寄希望于编译器会做严格的类型检查。 </p><p>因此，为了避免混乱，我们在编写 C&#x2F;C++程序时，对于任何函数都必须一个不漏地指定其类型。如果函数没有返回值，一定要声明为 void 类型。这既是程序良好可读性的需要，也是编程规范性的要求。另外，加上 void 类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。</p><h5 id="规则二：如果函数无参数，那么应声明其参数为-void-。"><a href="#规则二：如果函数无参数，那么应声明其参数为-void-。" class="headerlink" title="规则二：如果函数无参数，那么应声明其参数为 void 。"></a>规则二：如果函数无参数，那么应声明其参数为 void 。</h5><p>在 C++语言中声明一个这样的函数： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>&#125; <br></code></pre></td></tr></table></figure><p>则进行下面的调用是不合法的： </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span><span class="hljs-params">(2)</span>;<br></code></pre></td></tr></table></figure><p>因为在 C++中，函数参数为 void 的意思是这个函数不接受任何参数。 </p><p>我们在 Turbo C 2.0 中编译： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> \<span class="hljs-string">&quot;stdio.h\&quot; </span></span><br><span class="hljs-string"><span class="hljs-meta">fun() </span></span><br><span class="hljs-string"><span class="hljs-meta">&#123; </span></span><br><span class="hljs-string"><span class="hljs-meta">    return 1; </span></span><br><span class="hljs-string"><span class="hljs-meta">&#125; </span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">main() </span></span><br><span class="hljs-string"><span class="hljs-meta">&#123; </span></span><br><span class="hljs-string"><span class="hljs-meta">    printf(\&quot;%d\&quot;,fun(2)); getchar(); </span></span><br><span class="hljs-string"><span class="hljs-meta">&#125; </span></span><br></code></pre></td></tr></table></figure><p>编译正确且输出 1，这说明，在 C 语言中，可以给无参数的函数传送任意类型的参数，但是在 C++编译器中编译同样的代码则会出错。在 C++中，不能向无参数的函数传送任何参数，出错提示 “ ’fun’ : function does not take 1 parameters”。所以，无论在 C 还是 C++中，若函数不接受任何参数，一定要指明参数为 void。</p><h5 id="规则三：小心使用-void-指针类型"><a href="#规则三：小心使用-void-指针类型" class="headerlink" title="规则三：小心使用 void 指针类型"></a>规则三：小心使用 void 指针类型</h5><p>按照 ANSI(American National Standards Institute)标准，不能对 void 指针进行算法操作，即下列操作都是不合法的： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> * pvoid; <br>pvoid++; <span class="hljs-comment">//ANSI：错误 </span><br>pvoid += <span class="hljs-number">1</span>; <span class="hljs-comment">//ANSI：错误 </span><br><br><span class="hljs-comment">//ANSI 标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。 </span><br><span class="hljs-comment">//例如： </span><br><span class="hljs-type">int</span> *pint; <br>pint++; <span class="hljs-comment">//ANSI：正确，pint++的结果是使其增大 sizeof(int)。 </span><br></code></pre></td></tr></table></figure><p>但是大名鼎鼎的 GNU(GNU’s Not Unix 的缩写)则不这么认定，它指定 void *的算法操作与 char *一致。 因此下列语句在 GNU 编译器中皆正确： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">pvoid++; <span class="hljs-comment">//GNU：正确 </span><br><br>pvoid += <span class="hljs-number">1</span>; <span class="hljs-comment">//GNU：正确 pvoid++的执行结果是其增大了 1</span><br></code></pre></td></tr></table></figure><p>在实际的程序设计中，为迎合 ANSI 标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> * pvoid; <br>(<span class="hljs-type">char</span> *)pvoid++; <span class="hljs-comment">//ANSI：正确；GNU：正确 </span><br>(<span class="hljs-type">char</span> *)pvoid += <span class="hljs-number">1</span>; <span class="hljs-comment">//ANSI：错误；GNU：正确 </span><br></code></pre></td></tr></table></figure><p>GNU 和 ANSI 还有一些区别，总体而言，GNU 较 ANSI 更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合 ANSI 标准。</p><h5 id="规则四：如果函数的参数可以是任意类型指针，那么应声明其参数为-void-。"><a href="#规则四：如果函数的参数可以是任意类型指针，那么应声明其参数为-void-。" class="headerlink" title="规则四：如果函数的参数可以是任意类型指针，那么应声明其参数为 void *。"></a>规则四：如果函数的参数可以是任意类型指针，那么应声明其参数为 void *。</h5><p>典型的如内存操作函数 memcpy 和 memset 的函数原型分别为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> * <span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len)</span>;<br><span class="hljs-type">void</span> * <span class="hljs-title function_">memset</span><span class="hljs-params">( <span class="hljs-type">void</span> * buffer, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> num )</span>;<br></code></pre></td></tr></table></figure><p> 这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。如果 memcpy 和 memset 的参数类型不是 void *，而是 char *，那才叫真的奇怪了！这样的 memcpy 和 memset 明显不是一个“纯粹的，脱离低级趣味的” 函数！下面的代码执行正确： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//示例：memset 接受任意类型指针 </span><br><span class="hljs-type">int</span> intarray[<span class="hljs-number">100</span>]; [Page] <br><span class="hljs-built_in">memset</span> ( intarray, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) ); <span class="hljs-comment">//将 intarray 清 0 </span><br><br><span class="hljs-comment">//示例：memcpy 接受任意类型指针 </span><br><span class="hljs-type">int</span> intarray1[<span class="hljs-number">100</span>],intarray2[<span class="hljs-number">100</span>]; <br><span class="hljs-built_in">memcpy</span>(intarray1,intarray2,<span class="hljs-number">100</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//将 intarray2 拷贝给 intarray1</span><br></code></pre></td></tr></table></figure><p>有趣的是，memcpy 和 memset 函数返回的也是 void *类型，标准库函数的编写者是多么地富有学问啊！ </p><h5 id="规则五：void-不能代表一个真实的变量"><a href="#规则五：void-不能代表一个真实的变量" class="headerlink" title="规则五：void 不能代表一个真实的变量"></a>规则五：void 不能代表一个真实的变量</h5><p>下面代码都企图让 void 代表一个真实的变量，因此都是错误的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> a; <span class="hljs-comment">//错误</span><br>function(<span class="hljs-type">void</span> a); <span class="hljs-comment">//错误 </span><br></code></pre></td></tr></table></figure><p>void 体现了一种抽象，这个世界上的变量都是“有类型”的，譬如一个人不是男人就是女人（还有人妖？）。void 的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中“抽象基类”的概念，也很容易理解 void 数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个 void（让我们类比的称 void 为“抽象数据类型”）变量。 </p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>小小的 void 蕴藏着很丰富的设计哲学，作为一名程序设计人员，对问题进行深一个层次的思考必然使我们受益匪浅。</p><hr><h6 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>百度上搜的，到底哪来的忘了<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>-C语言</tag>
      
      <tag>-未知来源转载</tag>
      
      <tag>-编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>001_键盘两种输入模式是什么意思</title>
    <link href="/2022/03/28/001_%E9%94%AE%E7%9B%98%E4%B8%A4%E7%A7%8D%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    <url>/2022/03/28/001_%E9%94%AE%E7%9B%98%E4%B8%A4%E7%A7%8D%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<p>键盘上能用于切换“插入”与“覆盖（改写）”两种状态的双态键是INSERT键。Insert音标[ inˈsə:t] 发音为”因色特”。</p><p><a href="%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87"><img src="https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/7e3e6709c93d70cfb306aeb4fedcd100bba12b8e.jpg" alt="IMG_256"></a></p><p>插入键（Insert key，缩写INS）是<a href="https://www.baidu.com/s?wd=%E7%94%B5%E8%84%91%E9%94%AE%E7%9B%98&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">电脑键盘</a>的一个键，主要用于在文字处理器切换文本输入的模式。一种为覆盖模式，光标位置新输入字会替代原来的字；另一种为插入模式，新输入的字插入到光标位置，原来的字相应后移。在早期的计算机终端里，如果在覆盖模式，光标会变成一个方块而不是通常的竖线。</p><p>鼠标点击可输入框后会出现闪动的光标。 一般情况下，<a href="https://www.baidu.com/s?wd=Windows%E7%B3%BB%E7%BB%9F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">Windows系统</a>默认光标位置插入字符，而光标向后移动，即输入时对光标后字符无影响。 但是Insert是嵌入，即插入并覆盖，所以当按下Insert键后再输入，光标后的字符会被消去，即被当前输入字符替换掉，再次按下后则会还原到默认插入状态。</p><hr><h6 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>百度百科<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>-转载</tag>
      
      <tag>-Windows常识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld</title>
    <link href="/2022/03/28/HelloWorld/"/>
    <url>/2022/03/28/HelloWorld/</url>
    
    <content type="html"><![CDATA[<h2 id="花了半下午！"><a href="#花了半下午！" class="headerlink" title="花了半下午！"></a>花了半下午！</h2><p>虽然都是用别人现成的东西搭建的博客，但是还是遇到了好多问题，现在终于弄完了，哈哈纪念一下！</p><p><img src="/2022/03/28/HelloWorld/fw.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>-纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
